This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  (pages)/
    (auth)/
      sign-up/
        [[...sign-up]]/
          page.tsx
    articles/
      [id]/
        page.tsx
      components/
        article-card.tsx
      page.tsx
  (server)/
    (services)/
      articles.ts
      transcripts.ts
    actions/
      getYouTubeTranscriptAction.ts
    services/
      youtube.ts
  components/
    auth-button.tsx
    error-message.tsx
    floating-card.tsx
    floating-cards-container.tsx
    header.tsx
    url-input.tsx
  db/
    index.ts
    schema.ts
  globals.css
  layout.tsx
  page.tsx
drizzle/
  0000_loud_tomas.sql
  0001_pale_gorilla_man.sql
  0002_secret_warbird.sql
  0003_great_domino.sql
lib/
  types.ts
memory-bank/
  activeContext.md
  productContext.md
  progress.md
  projectbrief.md
  systemPatterns.md
  techContext.md
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
.clinerules
.gitignore
.repomixignore
drizzle.config.ts
eslint.config.mjs
middleware.ts
next.config.ts
package.json
postcss.config.js
README.md
tailwind.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/components/floating-card.tsx">
'use client';

import { motion } from 'framer-motion';
import { ReactNode, useState } from 'react';

interface FloatingCardProps {
  children: ReactNode;
  delay?: number;
}

export const FloatingCard = ({ children, delay = 0 }: FloatingCardProps) => {
  // ランダムな初期位置
  const [randomOffset] = useState({
    x: Math.random() * 20 - 10,
    y: Math.random() * 20 - 10,
  });

  const floatingAnimation = {
    initial: { 
      opacity: 0,
      y: 20,
    },
    animate: {
      opacity: 1,
      y: [
        randomOffset.y,
        randomOffset.y - 15,
        randomOffset.y + 15,
        randomOffset.y
      ],
      x: [
        randomOffset.x,
        randomOffset.x + 10,
        randomOffset.x - 10,
        randomOffset.x
      ],
      rotate: [0, 2, -2, 0],
      transition: {
        delay,
        duration: 12,
        repeat: Infinity,
        ease: "linear"
      }
    }
  };

  return (
    <motion.div
      className="floating-card"
      variants={floatingAnimation}
      initial="initial"
      animate="animate"
      whileHover={{
        scale: 1.05,
        transition: { duration: 0.2 }
      }}
    >
      {children}
    </motion.div>
  );
};
</file>

<file path="app/components/floating-cards-container.tsx">
'use client';

import { useInView } from 'react-intersection-observer';
import { FloatingCard } from './floating-card';
import Image from 'next/image';
import Link from 'next/link';
import { YouTubeService } from '@/app/(server)/services/youtube';
import type { Article } from '@/lib/types';

interface FloatingCardsContainerProps {
  articles: Article[];
}

// カードの配置を計算する関数
const calculateCardPosition = (index: number, total: number) => {
  const radius = 300; // 配置半径
  const angle = (index / total) * Math.PI * 2;
  const x = Math.cos(angle) * radius;
  const y = Math.sin(angle) * radius;

  // スタイルオブジェクトを返す
  return {
    position: 'absolute' as const,
    left: `calc(50% + ${x}px)`,
    top: `calc(50% + ${y}px)`,
    transform: 'translate(-50%, -50%)',
  };
};

export const FloatingCardsContainer = ({ articles }: FloatingCardsContainerProps) => {
  const [ref, inView] = useInView({
    triggerOnce: true,
    threshold: 0.1,
  });

  return (
    <div 
      ref={ref}
      className="relative min-h-[600px] w-full overflow-hidden"
    >
      {articles.map((article, index) => (
        <div
          key={article.id}
          style={calculateCardPosition(index, articles.length)}
        >
          <FloatingCard delay={index * 0.2}>
            <Link 
              href={`/articles/${article.id}`} 
              className="block w-[300px] overflow-hidden backdrop-blur-md bg-gradient-to-b from-orange-50/80 to-orange-100/10 border border-orange-200/20 rounded-xl shadow-lg transition-opacity hover:opacity-90"
            >
              <div className="relative aspect-video">
                <Image
                  src={YouTubeService.getThumbnailUrl(article.videoId)}
                  alt={article.title}
                  fill
                  className="object-cover"
                  sizes="300px"
                  priority={false}
                />
              </div>
              <div className="p-4">
                <h3 className="text-xl font-semibold mb-2 text-gray-800 line-clamp-2">
                  {article.title}
                </h3>
              </div>
            </Link>
          </FloatingCard>
        </div>
      ))}
    </div>
  );
};
</file>

<file path="app/(pages)/(auth)/sign-up/[[...sign-up]]/page.tsx">
import { SignUp } from '@clerk/nextjs'

export default function Page() {
  return (
    <div className="flex justify-center items-center h-screen">
      <SignUp />
    </div>
  )
}
</file>

<file path="app/(pages)/articles/components/article-card.tsx">
import Image from "next/image";
import { YouTubeService } from "@/app/(server)/services/youtube";
import type { Article } from "@/lib/types";

interface ArticleCardProps {
  article: Article;
}

/**
 * 記事カードコンポーネント
 * 記事のサムネイルとタイトルを表示
 */
export function ArticleCard({ article }: ArticleCardProps) {
  const thumbnailUrl = YouTubeService.getThumbnailUrl(article.videoId);

  return (
    <div className="overflow-hidden rounded-lg border border-gray-200 bg-white shadow">
      <div className="relative aspect-video">
        <Image
          src={thumbnailUrl}
          alt={article.title}
          fill
          className="object-cover"
          sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          priority={false}
        />
      </div>
      <div className="p-4">
        <h3 className="text-lg font-semibold line-clamp-2">
          {article.title}
        </h3>
        <p className="mt-2 text-sm text-gray-600">
          {new Date(article.createdAt ?? new Date()).toLocaleDateString("ja-JP")}
        </p>
      </div>
    </div>
  );
}
</file>

<file path="app/(server)/services/youtube.ts">
/**
 * YouTubeサービス
 * YouTube関連の機能を提供するサービスクラス
 */
export class YouTubeService {
  /**
   * 動画IDからサムネイルURLを生成
   * @param videoId - YouTubeの動画ID
   * @returns サムネイルのURL（HQ品質）
   */
  static getThumbnailUrl(videoId: string): string {
    return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
  }
}
</file>

<file path="app/components/auth-button.tsx">
'use client'

import { UserButton, SignInButton, useAuth } from '@clerk/nextjs'
import Link from 'next/link'
import { usePathname } from 'next/navigation'

export function AuthButton() {
  return (
    <div>
      <UserButton />
    </div>
  )
}

export function SignInButtonComponent() {  // asyncを削除
  const { userId } = useAuth()  // awaitを削除
  const pathname = usePathname()
  const showSignInButton = !userId && pathname !== '/sign-up'

    return (
      showSignInButton && (
        <Link href="/sign-up">
          <button className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
            ログイン
          </button>
        </Link>
      )
    )
  }
</file>

<file path="app/components/error-message.tsx">
'use client'

export function ErrorMessage({ message }: { message: string }) {
  return (
    <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded relative" role="alert">
      <span className="block sm:inline">{message}</span>
    </div>
  )
}
</file>

<file path="drizzle/0001_pale_gorilla_man.sql">
ALTER TABLE "youtube_blog_ai"."articles" DROP CONSTRAINT "articles_userId_users_id_fk";
--> statement-breakpoint
ALTER TABLE "youtube_blog_ai"."transcripts" DROP CONSTRAINT "transcripts_userId_users_id_fk";
--> statement-breakpoint
ALTER TABLE "youtube_blog_ai"."articles" ALTER COLUMN "userId" SET DATA TYPE text;--> statement-breakpoint
ALTER TABLE "youtube_blog_ai"."transcripts" ALTER COLUMN "userId" SET DATA TYPE text;
</file>

<file path="drizzle/0002_secret_warbird.sql">
-- 既存のデータを一時的に保存
ALTER TABLE "youtube_blog_ai"."transcripts" ADD COLUMN "transcript_temp" jsonb;
UPDATE "youtube_blog_ai"."transcripts" SET "transcript_temp" = "transcript"::jsonb WHERE "transcript" IS NOT NULL;

-- 元のカラムを削除して新しいカラムを追加
ALTER TABLE "youtube_blog_ai"."transcripts" DROP COLUMN "transcript";
ALTER TABLE "youtube_blog_ai"."transcripts" ADD COLUMN "transcript" jsonb;

-- データを戻す
UPDATE "youtube_blog_ai"."transcripts" SET "transcript" = "transcript_temp";
ALTER TABLE "youtube_blog_ai"."transcripts" DROP COLUMN "transcript_temp";
</file>

<file path="drizzle/0003_great_domino.sql">
ALTER TABLE "youtube_blog_ai"."articles" ADD COLUMN "transcriptId" uuid NOT NULL;--> statement-breakpoint
ALTER TABLE "youtube_blog_ai"."articles" ADD CONSTRAINT "articles_transcriptId_transcripts_id_fk" FOREIGN KEY ("transcriptId") REFERENCES "youtube_blog_ai"."transcripts"("id") ON DELETE no action ON UPDATE no action;
</file>

<file path="lib/types.ts">
import { InferInsertModel, InferSelectModel } from 'drizzle-orm';
import { users, articles, transcripts } from '../app/db/schema';

// Users table types
export type User = InferSelectModel<typeof users>;
export type NewUser = InferInsertModel<typeof users>;

// Articles table types
export type Article = InferSelectModel<typeof articles>;
export type NewArticle = InferInsertModel<typeof articles>;

// Transcripts table types
export type Transcript = InferSelectModel<typeof transcripts>;
export type NewTranscript = InferInsertModel<typeof transcripts>;

// API Response types

 // Start of Selection
export type YouTubeTranscriptSegment = {
  text: string; // テキスト
  start: number; // 開始時間
  duration: number; // 持続時間
  language: string; // 言語
};
</file>

<file path="memory-bank/projectbrief.md">
# YouTube字幕ブログ生成プラットフォーム - プロジェクト概要

## プロジェクトの目的
YouTube動画の字幕を自動取得し、AIを活用して構造化されたブログ記事を生成するプラットフォームを構築する。ユーザーフレンドリーなインターフェースを通じて、動画コンテンツを効率的にブログ記事化することを目指す。

## 主要目標
1. YouTube URLからの自動字幕取得
2. AIによる高品質なブログ記事生成
3. ユーザーフレンドリーなインターフェース提供
4. 多言語字幕対応
5. スケーラブルなサーバーレスアーキテクチャの実現

## 成功基準
- URLを入力するだけで記事が生成できる簡単な操作性
- 字幕の正確な取得と適切な前処理
- AIによる構造化された読みやすい記事生成
- 安定したシステムパフォーマンス
- セキュアな認証システム

## プロジェクトスコープ
### 含まれるもの
- YouTube URL入力と検証機能
- 字幕取得と前処理システム
- AI記事生成エンジン
- ユーザー認証システム
- 記事保存と管理機能

### 含まれないもの
- 動画のダウンロード機能
- コメント解析機能
- SNS連携機能
- 記事編集機能（初期バージョン）

## ステークホルダー
- コンテンツクリエイター
- ブロガー
- メディア運営者
- 開発チーム
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path=".repomixignore">
.history
drizzle/meta
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ['Inter var', 'sans-serif'],
      },
    },
  },
  plugins: [require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
  ]
  ,
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="app/(pages)/articles/[id]/page.tsx">
import { auth } from '@clerk/nextjs/server';
import { getArticle } from '@/app/(server)/(services)/articles';
import { notFound } from 'next/navigation';
import { Metadata } from 'next';
import Image from 'next/image';
import { YouTubeService } from '@/app/(server)/services/youtube';
// 動的メタデータの生成
export async function generateMetadata({ 
  params 
}: { 
  params: { id: string } 
}): Promise<Metadata> {
  const resolvedParams = await params;
  const article = await getArticle(resolvedParams.id);
  
  if (!article) {
    return {
      title: '記事が見つかりません',
    };
  }

  return {
    title: article.title,
    description: `${article.title}の記事ページです。`,
  };
}

export default async function ArticlePage({
  params
}: {
  params: { id: string }
}) {
  const resolvedParams = await params;
  const article = await getArticle(resolvedParams.id);
  
  if (!article) {
    notFound();
  }

  return (
    <article className="container mx-auto px-4 py-8">
      <div className="max-w-4xl mx-auto">
        <header className="mb-8">
          {/* サムネイル */}
          <div className="relative aspect-video mb-6 rounded-lg overflow-hidden">
            <Image
              src={YouTubeService.getThumbnailUrl(article.videoId)}
              alt={article.title}
              fill
              className="object-cover"
              priority
            />
          </div>

          {/* タイトル */}
          <h1 className="text-3xl font-bold tracking-tight text-gray-900 sm:text-4xl mb-4">
            {article.title}
          </h1>
          
          {/* メタ情報 */}
          <div className="flex items-center text-sm text-gray-600">
            <time dateTime={article.createdAt?.toISOString()}>
              {article.createdAt 
                ? new Date(article.createdAt).toLocaleDateString('ja-JP', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                  })
                : '不明'
              }
            </time>
          </div>
        </header>

        本文
        <div 
          className="prose article-content"
          dangerouslySetInnerHTML={{ __html: article.content }}
        />
      </div>
    </article>
  );
}
</file>

<file path="app/(pages)/articles/page.tsx">
import { auth } from '@clerk/nextjs/server';
import { getArticles } from '@/app/(server)/(services)/articles';
import Link from 'next/link';
import { ArticleCard } from './components/article-card';

export default async function ArticlesPage() {
  const { userId } = await auth();
  if (!userId) {
    return <div>ログインが必要です</div>;
  }

  const articles = await getArticles();

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">記事一覧</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {articles.map((article) => (
          <Link
            key={article.id}
            href={`/articles/${article.id}`}
            className="block hover:opacity-80 transition-opacity"
          >
            <ArticleCard article={article} />
          </Link>
        ))}
        {articles.length === 0 && (
          <div className="text-center text-gray-600">
            記事がまだありません
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/components/header.tsx">
import { auth } from '@clerk/nextjs/server'
import Link from 'next/link'
import { AuthButton, SignInButtonComponent } from './auth-button'

export async function Header() {
  const { userId } = await auth()

  return (
    <header className="bg-white shadow-sm">
      <div className="container mx-auto px-4 py-3 flex justify-between items-center">
        <Link href="/" className="text-xl font-semibold text-gray-800 hover:text-gray-600 transition-colors">
          YouTube Blog AI
        </Link>
        <div>
          {userId ? (
            <AuthButton />
          ) : (
            <SignInButtonComponent />
          )}
        </div>
      </div>
    </header>
  )
}
</file>

<file path="app/db/index.ts">
import { drizzle } from 'drizzle-orm/postgres-js'
import postgres from 'postgres'

const connectionString = process.env.DATABASE_URL!

const client = postgres(connectionString, { prepare: false })
const db = drizzle(client);

export default db;
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 255, 243, 224;
  --background-end-rgb: 255, 255, 255;
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
    to bottom,
    rgb(var(--background-start-rgb)),
    rgb(var(--background-end-rgb))
  );
  min-height: 100vh;
}

/* フローティングカードのカスタムスタイル */
.floating-card {
  position: relative;
  will-change: transform;
  transform-style: preserve-3d;
  perspective: 1000px;
}

/* ガラスモーフィズム効果 */
.glassmorphism {
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

/* グラデーションアニメーション */
@keyframes gradient {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

.gradient-animate {
  background: linear-gradient(
    -45deg,
    rgba(255,243,224,0.8),
    rgba(255,183,77,0.2),
    rgba(255,243,224,0.8)
  );
  background-size: 200% 200%;
  animation: gradient 15s ease infinite;
}

/* カスタムシャドウ効果 */
.shadow-float {
  box-shadow: 
    0 4px 6px -1px rgba(0, 0, 0, 0.1),
    0 2px 4px -1px rgba(0, 0, 0, 0.06),
    0 0 0 1px rgba(255, 183, 77, 0.1);
}

/* ホバーエフェクト */
.hover-float {
  transition: all 0.3s ease;
}

.hover-float:hover {
  transform: translateY(-5px);
  box-shadow: 
    0 10px 20px -5px rgba(0, 0, 0, 0.1),
    0 4px 6px -2px rgba(0, 0, 0, 0.05),
    0 0 0 1px rgba(255, 183, 77, 0.2);
}

/* アニメーション最適化 */
* {
  backface-visibility: hidden;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Reduce motion if preferred */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}
</file>

<file path="app/layout.tsx">
import { ClerkProvider } from '@clerk/nextjs'
import { Inter } from 'next/font/google'
import { Header } from './components/header'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata = {
  title: 'YouTube Blog AI',
  description: 'YouTubeの動画から簡単にブログ記事を生成',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <ClerkProvider>
      <html lang="ja">
        <body className={inter.className}>
          <div className="min-h-screen bg-gray-50">
            <Header />
            <main>
              {children}
            </main>
          </div>
        </body>
      </html>
    </ClerkProvider>
  )
}
</file>

<file path="drizzle/0000_loud_tomas.sql">
CREATE SCHEMA IF NOT EXISTS "youtube_blog_ai";

CREATE TABLE IF NOT EXISTS "youtube_blog_ai"."articles" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"userId" uuid NOT NULL,
	"videoId" text NOT NULL,
	"title" text NOT NULL,
	"content" text NOT NULL,
	"language" text NOT NULL,
	"createdAt" timestamp DEFAULT now(),
	"updatedAt" timestamp DEFAULT now()
);

CREATE TABLE IF NOT EXISTS "youtube_blog_ai"."transcripts" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"userId" uuid NOT NULL,
	"videoId" text NOT NULL,
	"transcript" text NOT NULL,
	"language" text NOT NULL,
	"createdAt" timestamp DEFAULT now()
);

CREATE TABLE IF NOT EXISTS "youtube_blog_ai"."users" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"email" text NOT NULL,
	"fullName" text,
	"createdAt" timestamp DEFAULT now(),
	"updatedAt" timestamp DEFAULT now(),
	CONSTRAINT "users_email_unique" UNIQUE("email")
);

-- 既存の制約が存在しない場合のみ追加する
ALTER TABLE "youtube_blog_ai"."articles" ADD CONSTRAINT "articles_userId_users_id_fk" FOREIGN KEY ("userId") REFERENCES "youtube_blog_ai"."users"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

ALTER TABLE "youtube_blog_ai"."transcripts" ADD CONSTRAINT "transcripts_userId_users_id_fk" FOREIGN KEY ("userId") REFERENCES "youtube_blog_ai"."users"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
</file>

<file path="memory-bank/productContext.md">
# プロダクトコンテキスト

## ユーザーペルソナ

### プライマリーペルソナ
1. **コンテンツクリエイター**
   - YouTubeチャンネルを運営
   - 動画コンテンツの文字起こしニーズが高い
   - ブログでのマルチチャネル展開を望む

2. **ブロガー/ライター**
   - YouTube動画を記事のソースとして活用
   - 効率的な記事作成プロセスを求める
   - 品質の高い記事生成を重視

### セカンダリーペルソナ
1. **メディア運営者**
   - 大量のコンテンツ生成ニーズ
   - チーム内での共有・管理が必要
   - 一貫した品質管理を重視

## ユーザージャーニー
```mermaid
journey
    title ユーザージャーニーマップ
    section 記事生成
        URL入力: 5: ユーザー
        字幕取得: 3: システム
        AI処理: 3: システム
        記事確認: 4: ユーザー
        保存/共有: 5: ユーザー
```

## ユーザー体験目標
1. **シンプルさ**
   - 最小限の入力で記事生成
   - 直感的なUI/UX
   - クリアな進行状況表示

2. **スピード**
   - 素早い字幕取得
   - 効率的な記事生成
   - レスポンシブな画面遷移

3. **品質**
   - 正確な字幕取得
   - 構造化された記事フォーマット
   - 自然な文章生成

4. **信頼性**
   - 安定したシステム動作
   - エラー時の適切なフィードバック
   - データの永続性保証

## 機能優先順位
### P0（必須機能）
- YouTube URL入力
- 字幕取得
- 記事生成
- 基本的なエラーハンドリング

### P1（重要機能）
- ユーザー認証
- 記事保存
- 進行状況表示
- 基本的な記事フォーマット選択

### P2（追加機能）
- 複数言語対応
- カスタムプロンプト
- 記事プレビュー
- 共有機能

## 品質基準
### コンテンツ品質
1. **記事構造**
   - 明確な見出し階層
   - 適切な段落分割
   - 一貫した文体

2. **内容の正確性**
   - 元動画の主要ポイントを網羅
   - 文脈の適切な解釈
   - 誤訳・誤変換の最小化

### システム品質
1. **パフォーマンス最適化**
   - Server Componentsによる高速な初期表示
     - 3秒以内のページロード
     - ストリーミングレンダリングの活用
   - Server Actionsによる効率的なデータ処理
     - 30秒以内の記事生成
     - 最適化されたデータフェッチ
   - 最小限のクライアントサイドJS
     - 必要な場合のみClient Components使用
     - バンドルサイズの最適化

2. **システム信頼性**
   - サーバーサイドロジックの集中管理
     - サービスレイヤーでの一元的なエラーハンドリング
     - ビジネスロジックの一貫性確保
   - 堅牢なデータ処理
     - Drizzle ORMの型安全性活用
     - トランザクション管理の確実性
   - セキュアな実装
     - Server Componentsでの安全なデータフェッチ
     - Server Actionsでの入力検証

## フィードバックと改善
1. **ユーザー体験モニタリング**
   - Server Componentsのパフォーマンス計測
   - Server Actionsの応答時間追跡
   - ページ遷移の体験評価

2. **システムモニタリング**
   - コンポーネントレベルのパフォーマンス
   - サービスレイヤーのエラー率
   - データフェッチの効率性

3. **継続的改善プロセス**
   - Server Componentsの最適化
   - サービスレイヤーの改善
   - 型安全性の向上
   - アーキテクチャパターンの洗練化
</file>

<file path=".clinerules">
# YouTube字幕ブログ生成プラットフォーム - プロジェクトルール

## プロジェクト構造
```
youtube-blog-ai/
├── app/                   # Next.js App Router構造
│   ├── api/              # APIルート
│   ├── components/       # 共通コンポーネント
│   ├── hooks/           # カスタムフック
│   ├── lib/             # ユーティリティ関数
│   ├── types/           # 型定義
│   └── utils/           # ヘルパー関数
├── memory-bank/          # プロジェクトドキュメント
└── public/              # 静的アセット
```

## コーディング規約

### 1. TypeScript
- 型定義は明示的に記述
- interfaceよりもtype aliasを優先使用
- as型アサーションは最小限に抑える

### 2. コンポーネント
- Atomic Designパターンの採用
- Server/Clientコンポーネントの明確な区分け
- Props型の厳密な定義

### 3. 状態管理
- Server Componentsを最大限活用
- クライアント状態の最小化
- フォーム状態はreact-hook-formで管理

### 4. エラーハンドリング
- APIエラーは統一フォーマットで返却
- クライアントエラーは適切なUI表示
- エラーログの詳細な記録

### 5. 命名規則
- コンポーネント: PascalCase
- 関数: camelCase
- 定数: SCREAMING_SNAKE_CASE
- type/interface: PascalCase
- ファイル名: kebab-case

## 実装パターン

### 1. APIレスポンス型
```typescript
type ApiResponse<T> = {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
  };
};
```

### 2. APIエラーハンドリング
```typescript
const handleApiError = (error: unknown): ApiResponse<never> => {
  if (error instanceof Error) {
    return {
      success: false,
      error: {
        code: 'UNKNOWN_ERROR',
        message: error.message
      }
    };
  }
  return {
    success: false,
    error: {
      code: 'UNKNOWN_ERROR',
      message: '不明なエラーが発生しました'
    }
  };
};
```

### 3. データベースアクセス
```typescript
// Supabaseクライアント
import { createClient } from '@supabase/supabase-js';
export const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

// Drizzle設定
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import { migrate } from 'drizzle-orm/postgres-js/migrator';

const queryClient = postgres(process.env.DATABASE_URL!);
export const db = drizzle(queryClient);

// マイグレーション実行
const runMigrations = async () => {
  await migrate(db, { migrationsFolder: 'drizzle' });
};
```

### 4. 認証ミドルウェア
```typescript
import { authMiddleware } from "@clerk/nextjs";
 
export default authMiddleware({
  publicRoutes: ["/", "/api/health"],
  ignoredRoutes: ["/api/webhooks(.*)"]
});
```

## 重要な実装注意点

### 1. パフォーマンス
- Server Componentsの適切な使用
- 画像の最適化
- 適切なキャッシング戦略

### 2. セキュリティ
- 環境変数の厳格な管理
- APIルートの認証チェック
- ユーザー入力の検証

### 3. アクセシビリティ
- セマンティックなHTML
- ARIA属性の適切な使用
- キーボード操作のサポート

### 4. テスト
- ユニットテストの必須化
- インテグレーションテストの実装
- E2Eテストの計画的実施
</file>

<file path="drizzle.config.ts">
import type { Config } from "drizzle-kit";
import { loadEnvConfig } from "@next/env";

loadEnvConfig(process.cwd());

export default {
  schema: "./app/db/schema.ts",
  out: "./drizzle",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
} satisfies Config;
</file>

<file path="eslint.config.mjs">
module.exports = {
  extends: [
    'next/core-web-vitals',
  ],
  rules: {
    '@typescript-eslint/no-var-requires': 'off',
  },
}
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  images: {
    remotePatterns: [
      {
        hostname: "img.youtube.com",
      },
    ],
  },
};

export default nextConfig;
</file>

<file path="app/(server)/(services)/transcripts.ts">
'server only'
import db from '@/app/db';
import { transcripts } from '@/app/db/schema';
import { eq, and } from 'drizzle-orm';
import type { NewTranscript, Transcript } from '@/lib/types';

/**
 * 字幕データを作成する
 */
export const createTranscript = async (data: NewTranscript): Promise<Transcript> => {
  try {
    const [transcript] = await db
      .insert(transcripts)
      .values(data)
      .returning();
    
    return transcript;
  } catch (error) {
    console.error('Error creating transcript:', error);
    throw error;
  }
};
</file>

<file path="app/page.tsx">
import { FloatingCardsContainer } from './components/floating-cards-container';
import { URLInput } from './components/url-input';
import { getArticles } from './(server)/(services)/articles';

// 記事データを取得
async function getData() {
  const articles = await getArticles();
  return { articles };
}

export default async function Home() {
  const { articles } = await getData();
  return (
    <main className="min-h-screen bg-gradient-to-b from-orange-50 to-white">
      {/* ヘッダーセクション */}
      <section className="py-16 px-4 text-center">
        <h1 className="text-4xl font-bold text-gray-800 mb-4">
          YouTube字幕ブログジェネレーター
        </h1>
        <p className="text-gray-600 max-w-2xl mx-auto mb-8">
          YouTubeの動画から自動で魅力的なブログ記事を生成。AIの力で、コンテンツの可能性を広げましょう。
        </p>
        
        {/* URL入力フォーム */}
        <div className="max-w-xl mx-auto">
          <URLInput />
        </div>
      </section>

      {/* フローティングカードセクション */}
      <section className="mt-16">
        <FloatingCardsContainer articles={articles} />
      </section>
    </main>
  );
}
</file>

<file path="memory-bank/activeContext.md">
# アクティブコンテキスト

## 現在のフェーズ
- アーキテクチャ再構築フェーズ
- Server Components優先アプローチへの移行
- サーバーサイドロジックの整理

## 最近の変更
- アーキテクチャの方針更新
  - Server Components優先の採用
  - サーバーサイドロジックの構造化
  - APIルートの最小限化
- ディレクトリ構造の整理
  - (server)フォルダーの導入
  - ルートごとのコンポーネント分離

## 進行中のタスク
1. **アーキテクチャ再構築**
   - [ ] Server Componentsへの移行
   - [ ] サーバーサイドロジックの整理
   - [ ] コンポーネント構造の見直し

2. **サーバーサイド実装**
   - [ ] サービスレイヤーの実装
     ```
     app/(server)/services/
     ├── articles.ts
     ├── youtube.ts
     └── openai.ts
     ```
   - [ ] Server Actionsの実装
     ```
     app/(server)/actions/
     ├── articles.ts
     └── generate.ts
     ```

3. **データアクセス最適化**
   - [ ] Drizzle ORMの型活用
   - [ ] クエリの効率化
   - [ ] エラーハンドリングの実装

## 優先度の高い実装項目
1. **コアロジック**
   - [ ] サービスレイヤーの基盤実装
   - [ ] Server Actionsの基盤実装
   - [ ] エラーハンドリング基盤の実装

2. **UI実装**
   - [ ] Server Components実装
   - [ ] 必要最小限のClient Components特定
   - [ ] フォーム処理のServer Actions化

3. **データ層**
   - [ ] Drizzleスキーマの最適化
   - [ ] 型定義の活用
   - [ ] マイグレーション管理

## 現在の課題
1. **技術的課題**
   - Server Componentsでのデータフェッチ最適化
   - Server Actionsのエラーハンドリング
   - 型安全性の確保

2. **構造的課題**
   - ロジックの適切な分離
   - コンポーネントの適切な配置
   - 型定義の管理

## 次のステップ
1. サーバーサイドロジックの実装
   ```
   app/(server)/
   ├── services/
   │   ├── articles.ts
   │   ├── youtube.ts
   │   └── openai.ts
   └── actions/
       ├── articles.ts
       └── generate.ts
   ```
2. コンポーネントの再構築
   - ルートごとのコンポーネントフォルダー作成
   - Server/Client分離の明確化
3. 型システムの整備
   - Drizzle生成の型の活用
   - 共通型定義の整理

## アクティブな決定事項
1. **アーキテクチャ**
   - Server Components優先
   - サーバーサイドロジックの集中管理
   - APIルートの最小限使用

2. **実装方針**
   - ロジックはサービスレイヤーに集中
   - フォーム処理はServer Actions
   - 型はDrizzle ORMから生成
   - シンプルな実装を維持

3. **コード構成**
   - ルートごとのコンポーネント分離
   - サーバーロジックの明確な構造化
   - 最小限のClient Components

## 留意点
- Server Componentsでのデータフェッチを優先
- Client Componentsは必要な場合のみ使用
- サービスレイヤーでのロジック集中
- 型安全性の確保
</file>

<file path="memory-bank/progress.md">
# プロジェクト進捗状況

## 完了した作業
1. **プロジェクト設計**
   - ✅ プロジェクト仕様書の作成
   - ✅ システムアーキテクチャの設計
   - ✅ Memory Bankの初期設定

## 進行中の作業
1. **環境設定**
   - [ ] Next.jsプロジェクトの確認
   - [ ] 必要なパッケージのインストール
   - [ ] 環境変数の設定

2. **認証システム**
   - [ ] Clerkのセットアップ
   - [ ] 認証フローの実装
   - [ ] 保護されたルートの設定

3. **データベース**
   - [x] Supabaseプロジェクトの作成
   - [x] データベーススキーマの設計（Drizzle）
   - [x] マイグレーションの実行
   - [ ] サービスレイヤーの実装
     - [ ] app/services/articles.ts
     - [ ] app/services/transcripts.ts
   - [ ] Server Actionsの実装
     - [ ] app/actions.ts

## 今後の作業
1. **サーバーサイド実装**
   - [ ] サービスレイヤーの実装（app/(server)/services/）
     ```
     ├── articles.ts  # 記事関連のロジック
     ├── youtube.ts   # YouTube API関連
     └── openai.ts    # AI生成関連
     ```
   - [ ] Server Actionsの実装（app/(server)/actions/）
     ```
     ├── articles.ts  # 記事関連のアクション
     └── generate.ts  # 生成関連のアクション
     ```
   - [ ] 型システムの整備
     - [ ] Drizzle ORMの型活用
     - [ ] サービス層の型定義

2. **UI実装（Server Components優先）**
   - [ ] ルートごとのコンポーネント構造
     ```
     app/
     ├── articles/
     │   └── components/  # 記事関連コンポーネント
     └── dashboard/
         └── components/  # ダッシュボード関連
     ```
   - [ ] Server Componentsでのデータフェッチ
   - [ ] 必要最小限のClient Components

3. **テスト実装**
   - [ ] サービスレイヤーのユニットテスト
   - [ ] Server Actionsのテスト
   - [ ] コンポーネントテスト

## 既知の課題
1. **技術的課題**
   - Server Componentsでのストリーミング最適化
   - Server Actionsのエラーハンドリング
   - データフェッチの効率化

2. **アーキテクチャ課題**
   - サーバー/クライアントの適切な分離
   - ロジックの適切な配置
   - 型安全性の確保

## リスク管理
1. **技術的リスク**
   - Server Components移行の複雑さ
   - 型安全性の確保
   - パフォーマンスの最適化

2. **対策**
   - 段階的なServer Components移行
   - Drizzle ORMの型システム活用
   - Server Actionsの適切な設計

## 次のマイルストーン
1. **Phase 1: サーバーサイド基盤**
   - [ ] サービスレイヤー実装
   - [ ] Server Actions実装
   - [ ] 型システム整備

2. **Phase 2: UI実装**
   - [ ] Server Components実装
   - [ ] 必要なClient Components実装
   - [ ] フォーム処理のServer Actions化

3. **Phase 3: 最適化**
   - [ ] パフォーマンス改善
   - [ ] エラーハンドリング強化
   - [ ] キャッシング戦略実装

## 品質指標
1. **パフォーマンス**
   - [ ] Server Componentsのロード時間
   - [ ] Server Actionsの応答時間
   - [ ] メモリ使用率の監視

2. **コード品質**
   - [ ] 型カバレッジ
   - [ ] テストカバレッジ
   - [ ] エラーハンドリングの完全性

## 更新履歴
- 2025/03/19: プロジェクト仕様書作成、Memory Bank初期設定
- 2025/03/20: データベーススキーマ設計完了、マイグレーション実行
- 2025/03/22: アーキテクチャ方針の更新（Server Components優先）
</file>

<file path="middleware.ts">
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isPublicRoute = createRouteMatcher(['/sign-in(.*)', '/(.*)'])

export default clerkMiddleware(async (auth, req) => {
  if (!isPublicRoute(req)) {
    await auth.protect()
  }
})

export const config = {
  matcher: [
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    '/(api|trpc)(.*)',
  ],
}
</file>

<file path="app/components/url-input.tsx">
'use client'

import { useState } from 'react'
import { useForm } from 'react-hook-form'
import { useRouter } from 'next/navigation'
import { ErrorMessage } from './error-message'
import { getYouTubeTranscriptAction } from '../(server)/actions/getYouTubeTranscriptAction'

type UrlFormData = {
  url: string
}

export function URLInput() {
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const { register, handleSubmit, formState: { errors } } = useForm<UrlFormData>()



  return (
    <form action={async (formData: FormData) => {
      setIsLoading(true)
      const result = await getYouTubeTranscriptAction(formData)
      if (result.success) {
        setIsLoading(false)
        if (result.data?.redirect) {
          router.push(result.data.redirect)
        }
      } else {
        setError(result.error?.message || 'エラーが発生しました')
        setIsLoading(false)
      }
    }} className="space-y-4">
      <div className="space-y-4">
        <div className="relative">
          <input
            {...register('url', {
              required: 'URLを入力してください',
              pattern: {
                value: /^(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/)[a-zA-Z0-9_-]+/,
                message: '有効なYouTube URLを入力してください'
              }
            })}
            type="url"
            placeholder="https://www.youtube.com/watch?v=..."
            className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          />
          <button
            type="submit"
            disabled={isLoading}
            className="absolute right-2 top-2 px-4 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
          >
            {isLoading ? '処理中...' : '生成'}
          </button>
        </div>
        {(errors.url || error) && (
          <ErrorMessage message={errors.url?.message || error || ''} />
        )}
      </div>
    </form>
  )
}
</file>

<file path="memory-bank/techContext.md">
# 技術コンテキスト

## 技術スタック
### アプリケーション構造
- **Next.js** - Reactフレームワーク
  - App Router
  - Server Components（優先使用）
  - Client Components（必要最小限）
  - Server Actions（フォーム処理）

### Page Component型定義
```typescript
// ダイナミックルートのページコンポーネント
type PageProps = {
  params: { [key: string]: string }
  searchParams?: { [key: string]: string | string[] | undefined }
}

export default async function Page({ params, searchParams }: PageProps) {
  // ...
}
```

### バックエンド構造
- **Server Components** - データフェッチ
- **Server Actions** - サーバーサイド処理
- **サービスレイヤー** - ビジネスロジック

### データ層
- **Supabase** (PostgreSQL)
  - データベースホスティング
  - Row Level Security
  - ストレージ
- **Drizzle ORM**
  - 型安全なクエリ構築
  - スキーマファーストアプローチ
  - 自動生成された型定義の活用

### 認証
- **Clerk**
  - ユーザー認証
  - セッション管理
  - 権限制御

### 外部API・ライブラリ
- **youtube-transcript** - 字幕取得ライブラリ
- **OpenAI API (GPT-4)** - AI文章生成

### デプロイ
- **Vercel** - サーバーレスプラットフォーム

## プロジェクト構成
```
app/
├── (server)/           # サーバーサイドロジック
│   ├── services/       # ドメインロジック
│   └── actions/        # Server Actions
├── articles/           # 記事関連ページ
│   ├── components/     # 記事専用コンポーネント
│   └── [id]/          # 記事詳細ページ
├── components/         # 共通コンポーネント
└── lib/               # ユーティリティ
```

## 開発要件
### 基本要件
- Node.js >= 18.x
- TypeScript（Strict Mode）
  - Next.js 14の型定義を厳密に使用
  - Page Propsの型定義を徹底
  - Drizzle型の活用
- ESLint + Prettier
- pnpm（パッケージマネージャー）

### 環境変数設定
- `OPENAI_API_KEY` - OpenAI APIキー
- `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` - Clerk公開キー
- `CLERK_SECRET_KEY` - Clerkシークレットキー
- `NEXT_PUBLIC_SUPABASE_URL` - SupabaseプロジェクトURL
- `NEXT_PUBLIC_SUPABASE_ANON_KEY` - Supabase匿名キー
- `SUPABASE_SERVICE_ROLE_KEY` - Supabaseサービスロールキー

## 技術的要件と制約
1. **パフォーマンス**
   - Server Componentsによる最適化
   - 必要最小限のClient Components
   - 適切なキャッシング戦略
   - 応答時間目標:
     - ページロード < 3秒
     - Server Action < 5秒

2. **スケーラビリティ**
   - Server Componentのストリーミング
   - Server Actionsの最適化
   - Supabaseコネクションプール管理

3. **セキュリティ**
   - Server Componentsでの安全なデータフェッチ
   - Server Actionsでのバリデーション
   - Row Level Securityの適切な設定
   - 環境変数の厳格な管理

4. **コード品質**
   - Server/Client分離の明確化
   - サービスレイヤーでのロジック集中
   - Drizzle ORMの型活用
   - ユニットテストの実装
</file>

<file path="app/(server)/actions/getYouTubeTranscriptAction.ts">
'use server'

import { auth } from '@clerk/nextjs/server'
import { YoutubeTranscript } from 'youtube-transcript'
import { createTranscript } from '../(services)/transcripts'
import { generateAndSaveArticle } from '../(services)/articles'
import { YouTubeTranscriptSegment } from '@/lib/types'
import { revalidatePath } from 'next/cache'
// URLからビデオIDを抽出する関数
function extractVideoId(url: string): string | null {
  try {
    const urlObj = new URL(url);
    if (urlObj.hostname === 'youtu.be') {
      return urlObj.pathname.slice(1);
    } else if (urlObj.hostname === 'www.youtube.com' || urlObj.hostname === 'youtube.com') {
      return urlObj.searchParams.get('v');
    }
    return null;
  } catch {
    return null;
  }
}

// ビデオIDを検証する関数
function validateVideoId(videoId: string | null): boolean {
  return Boolean(videoId && /^[a-zA-Z0-9_-]{11}$/.test(videoId));
}

export async function getYouTubeTranscriptAction(formData: FormData) {
  const userId = await auth();
  if (!userId) {
    return {
      success: false,
      error: {
        code: 'UNAUTHORIZED',
        message: '認証が必要です'
      }
    };
  }

  try {
    const url = formData.get('url') as string;
    const videoId = extractVideoId(url);

    if (!validateVideoId(videoId)) {
      return {
        success: false,
        error: {
          code: 'INVALID_URL',
          message: '無効なYouTube URLです'
        }
      };
    }

    // 字幕を取得
    const rawTranscript = await YoutubeTranscript.fetchTranscript(videoId as string);
    const transcript = rawTranscript.map(segment => ({
      text: segment.text,
      start: segment.offset,
      duration: segment.duration,
      language: segment.lang
    }));

    console.log(transcript[0].language);

    // 字幕を保存
    await createTranscript({
      userId: userId.userId as string,
      videoId: videoId as string,
      transcript: JSON.stringify(transcript),
      language: transcript[0].language as string, 
    });

    // 記事を生成して保存
    const article = await generateAndSaveArticle(
      userId.userId as string,
      videoId as string,
      transcript[0].language as string
    );

    revalidatePath('/');
    
    // 記事の生成に成功した場合は記事ページにリダイレクト
    return {
      success: true,
      data: {
        videoId,
        transcript,
        redirect: `/articles/${article.id}`
      }
    };


  } catch (error: any) {
    console.error('[Transcript Error]:', error);
    return {
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: error.message || '字幕の取得に失敗しました'
      }
    };
  }
}
</file>

<file path="app/db/schema.ts">
import { jsonb, pgSchema, pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';
// スキーマ名を定義
export const mySchema = pgSchema('youtube_blog_ai');


// ユーザーテーブル
export const users = mySchema.table('users', {
  id: uuid().primaryKey().defaultRandom(),
  email: text().notNull().unique(),
  fullName: text(),
  createdAt: timestamp().defaultNow(),
  updatedAt: timestamp().defaultNow(),
});

// 記事テーブル
export const articles = mySchema.table('articles', {
  id: uuid().primaryKey().defaultRandom(),
  userId: text().notNull(),
  videoId: text().notNull(),
  transcriptId: uuid().notNull().references(() => transcripts.id),
  title: text().notNull(),
  content: text().notNull(),
  language: text().notNull(),
  createdAt: timestamp().defaultNow(),
  updatedAt: timestamp().defaultNow(),
});

// 字幕テーブル
export const transcripts = mySchema.table('transcripts', {
  id: uuid().primaryKey().defaultRandom(),
  userId: text().notNull(),
  videoId: text().notNull(),
  transcript: jsonb().notNull(), // PostgreSQLの場合
  language: text().notNull(),
  createdAt: timestamp().defaultNow(),
});
</file>

<file path="memory-bank/systemPatterns.md">
# システムパターン設計

## アーキテクチャ概要
```mermaid
graph TD
    Client[Server Components] --> |1. Server Action呼び出し| Action[Server Actions]
    Action --> |2. サービス呼び出し| Service[サービスレイヤー]
    Service --> |3. 外部API呼び出し| External[外部API]
    Service --> |4. データ永続化| DB[Supabase]
    Client --> |5. 認証| Auth[Clerk認証]
```

## システムレイヤー
### 1. プレゼンテーション層
- Server Componentsを優先使用
- Client Componentsは必要最小限（例：インタラクティブなUI要素のみ）
- ルートごとに分離されたコンポーネント構造
  - 例：articles/components/
  - 例：dashboard/components/

### 2. サーバーサイド構造
- サーバーロジックの集中管理
  ```
  app/
  ├── (server)/
  │   ├── services/     # ドメインロジック・DB操作
  │   │   ├── articles.ts
  │   │   ├── youtube.ts
  │   │   └── openai.ts
  │   └── actions/      # Server Actions
  │       ├── articles.ts
  │       └── generate.ts
  ```
- Server Actionsによるフォーム処理
- APIルートの最小限使用

### 3. ドメインロジック（サービスレイヤー）
- モデルごとに分離されたサービス
  ```typescript
  // app/(server)/services/articles.ts
  export class ArticleService {
    // Drizzle ORMの型を活用
    async createArticle(data: InsertArticle) {
      return db.insert(articles).values(data);
    }
  }
  ```
- ビジネスロジックの集中管理
- 外部APIとの通信処理

### 4. インフラストラクチャ層
- Vercelでのサーバーレス構成
- Supabaseによるデータ永続化
  - Drizzle ORMによる型安全なクエリ
  - スキーマファーストアプローチ
- Clerkによる認証基盤

## データフロー
```mermaid
sequenceDiagram
    participant User as ユーザー
    participant SC as Server Component
    participant SA as Server Action
    participant SV as Service
    participant Ex as 外部API
    participant DB as Database

    User->>SC: フォーム送信
    SC->>SA: Server Action呼び出し
    SA->>SV: サービスメソッド呼び出し
    SV->>Ex: API要求
    Ex-->>SV: レスポンス
    SV->>DB: データ永続化
    DB-->>SV: 保存確認
    SV-->>SA: 処理結果
    SA-->>SC: レスポンス
    SC-->>User: UI更新
```

## 実装パターン
### 1. Page Component型定義パターン
```typescript
// ベース型定義
type BasePageProps = {
  params: { [key: string]: string }
  searchParams?: { [key: string]: string | string[] | undefined }
}

// 静的ページの例
// app/articles/page.tsx
export default async function ArticlesPage({
  searchParams
}: BasePageProps) {
  const articles = await db.query.articles.findMany();
  return (
    <div>
      {articles.map(article => (
        <ArticleCard key={article.id} article={article} />
      ))}
    </div>
  );
}

// 動的ルートページの例
// app/articles/[id]/page.tsx
export default async function ArticlePage({
  params
}: BasePageProps) {
  const article = await db.query.articles.findFirst({
    where: { id: params.id }
  });
  return <ArticleDetail article={article} />;
}
```

### 2. Server Actionパターン
```typescript
// app/(server)/actions/articles.ts
'use server'

import { db } from '@/db'
import { articles } from '@/db/schema'
import { Article, InsertArticle } from '@/db/types'

export async function createArticle(data: FormData): Promise<Article> {
  const articleData: InsertArticle = {
    title: data.get('title') as string,
    content: data.get('content') as string,
  };

  const articleService = new ArticleService();
  return articleService.create(articleData);
}
```

### 3. サービスレイヤーパターン
```typescript
// app/(server)/services/articles.ts
import { db } from '@/db'
import { articles } from '@/db/schema'
import { Article, InsertArticle } from '@/db/types'

export class ArticleService {
  async create(data: InsertArticle): Promise<Article> {
    return db.insert(articles).values(data).returning();
  }

  async generateFromYoutube(url: string): Promise<Article> {
    const transcript = await this.youtubeService.getTranscript(url);
    const content = await this.openaiService.generateArticle(transcript);
    return this.create({ title: transcript.title, content });
  }
}
```

## エラー処理
```typescript
// app/(server)/services/base.ts
export class BaseService {
  protected handleError(error: unknown) {
    // エラーログ記録
    console.error(error);
    
    // 構造化されたエラーレスポンス
    return {
      success: false,
      error: {
        message: error instanceof Error ? error.message : '不明なエラーが発生しました',
      }
    };
  }
}
```

## キャッシング戦略
1. **React Server Components**
   - デフォルトのキャッシング動作を活用
   - Route Segment Config でのカスタマイズ

2. **Server Actions**
   - クライアントキャッシュの活用
   - 楽観的更新の実装
</file>

<file path="app/(server)/(services)/articles.ts">
'server only'
import db from '@/app/db';
import { articles, transcripts } from '@/app/db/schema';
import { eq } from 'drizzle-orm';
import type { NewArticle, Article, Transcript } from '@/lib/types';
import { GoogleGenerativeAI } from '@google/generative-ai';

// Gemini APIの初期化
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);

/**
 * 字幕から記事を生成して保存する
 */
export const generateAndSaveArticle = async (userId: string, videoId: string, language: string = 'ja'): Promise<Article> => {
  try {
    // 字幕を取得
    const [transcriptData] = await db
      .select()
      .from(transcripts)
      .where(eq(transcripts.videoId, videoId))
      .limit(1);

    if (!transcriptData) {
      throw new Error('字幕が見つかりません');
    }

    // 字幕テキストを結合
    const transcriptContent = (transcriptData.transcript as { text: string }[])
      .map(segment => segment.text)
      .join('\n');

    // Geminiモデルを設定
    const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

    // プロンプトを作成
    const prompt = `以下のYouTube動画の字幕から、ブログ記事を生成してください。
字幕の内容を要約し、適切な見出しをつけて、読みやすい記事にしてください。
見出しはh1, h2, h3などのHTMLタグを使用してください。
段落はpタグで囲んでください。
重要な部分はstrongタグで強調してください。

字幕内容：
${transcriptContent}

出力形式：
{
  "title": "記事のタイトル",
  "content": "記事の本文（HTML形式）"
}

出力例：
{
  "title": "タイトル例",
  "content": "<article><h1>メインタイトル</h1><p>導入文...</p><h2>セクション1</h2><p>本文...<strong>重要なポイント</strong>...</p></article>"
}`;

    // 記事を生成
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    
    // レスポンステキストからJSONを抽出して正規化
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('生成された記事のフォーマットが不正です');
    }
    
    // 抽出したテキストを正規化
    let jsonText = jsonMatch[0]
      // 改行を削除
      .replace(/\n/g, ' ')
      // 連続する空白を1つに
      .replace(/\s+/g, ' ')
      // HTMLタグ内の余分な空白を削除
      .replace(/>\s+</g, '><')
      // 特殊文字をエスケープ
      .replace(/[\u0000-\u001F\u007F-\u009F]/g, '');

    console.log('Normalized JSON:', jsonText);
    
    try {
      // JSONをパース
      const article = JSON.parse(jsonText);
      
      // 必要なプロパティの存在チェック
      if (!article.title || !article.content) {
        throw new Error('記事のタイトルまたは本文が見つかりません');
      }
      
      // 記事を保存
      const createdArticle = await saveArticle({
        userId,
        videoId,
        transcriptId: transcriptData.id,
        title: article.title,
        content: article.content,
        language,
      });

      return createdArticle;
    } catch (error) {
      console.error('JSON Parse Error:', error);
      console.error('Raw JSON Text:', jsonText);
      throw new Error('記事の生成結果を解析できませんでした: ' + (error as Error).message);
    }
  } catch (error) {
    console.error('Error generating article:', error);
    throw error;
  }
};

/**
 * 記事を保存する
 */
export const saveArticle = async (data: NewArticle): Promise<Article> => {
  try {
    const [article] = await db
      .insert(articles)
      .values({
        ...data,
        transcriptId: data.transcriptId
      })
      .returning();
    
    return article;
  } catch (error) {
    console.error('Error creating article:', error);
    throw error;
  }
};

/**
 * 記事一覧を取得する
 */
export const getArticles = async (): Promise<Article[]> => {
  try {
    const result = await db
      .select()
      .from(articles);
    
    return result;
  } catch (error) {
    console.error('Error fetching articles:', error);
    throw error;
  }
};

/**
 * 記事を取得する
 */
export const getArticle = async (id: string): Promise<Article | null> => {
  try {
    const [article] = await db
      .select()
      .from(articles)
      .where(eq(articles.id, id))
      .limit(1);
    
    return article || null;
  } catch (error) {
    console.error('Error fetching article:', error);
    throw error;
  }
};
</file>

<file path="package.json">
{
  "name": "youtube-blog-ai",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "migrate": "tsx scripts/migrate.ts"
  },
  "dependencies": {
    "@clerk/nextjs": "^6.12.5",
    "@google/generative-ai": "^0.24.0",
    "@heroicons/react": "^2.2.0",
    "@supabase/supabase-js": "^2.49.1",
    "@tailwindcss/forms": "^0.5.10",
    "dotenv": "^16.4.7",
    "drizzle-orm": "^0.40.1",
    "framer-motion": "^12.5.0",
    "next": "15.2.3",
    "pg": "^8.14.1",
    "postgres": "^3.4.5",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.54.2",
    "react-intersection-observer": "^9.16.0",
    "youtube-transcript": "^1.2.1",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^20",
    "@types/pg": "^8.11.11",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "add": "^2.0.6",
    "autoprefixer": "^10.4.21",
    "bun": "^1.2.5",
    "drizzle-kit": "^0.30.5",
    "eslint": "^9",
    "eslint-config-next": "15.2.3",
    "postcss": "^8.5.3",
    "postcss-nesting": "^13.0.1",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.3",
    "typescript": "^5"
  }
}
</file>

</files>
